<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>TIGA NOTE</title><link>https://tiga210.github.io</link><description>Tiga的个人笔记，分享记录一些有趣好玩的技术</description><copyright>TIGA NOTE</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/10243912?v=4</url><title>avatar</title><link>https://tiga210.github.io</link></image><lastBuildDate>Fri, 21 Jun 2024 17:10:01 +0000</lastBuildDate><managingEditor>TIGA NOTE</managingEditor><ttl>60</ttl><webMaster>TIGA NOTE</webMaster><item><title>测试博客</title><link>https://tiga210.github.io/post/ce-shi-bo-ke.html</link><description># 测试博客

测试博客。</description><guid isPermaLink="true">https://tiga210.github.io/post/ce-shi-bo-ke.html</guid><pubDate>Thu, 20 Jun 2024 13:29:09 +0000</pubDate></item><item><title>使用Cloudflare代理Docker hub</title><link>https://tiga210.github.io/post/shi-yong-Cloudflare-dai-li-Docker%20hub.html</link><description>由于国内的一些dockerhub镜像下线，导致无法访问，参考 [https://global.v2ex.com/t/1007922](https://global.v2ex.com/t/1007922) 成功使用cloudflare进行代理&#13;
&#13;
&#13;
```js&#13;
'use strict'&#13;
const workers_url = 'https://你自己的域名'&#13;
const hub_host = 'registry-1.docker.io'&#13;
const auth_url = 'https://auth.docker.io'&#13;
&#13;
/**&#13;
 * static files (404.html, sw.js, conf.js)&#13;
 */&#13;
&#13;
/** @type {RequestInit} */&#13;
const PREFLIGHT_INIT = {&#13;
// status: 204,&#13;
    headers: new Headers({&#13;
        'access-control-allow-origin': '*',&#13;
        'access-control-allow-methods': 'GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS',&#13;
        'access-control-max-age': '1728000',&#13;
    }),&#13;
}&#13;
&#13;
/**&#13;
 * @param {any} body&#13;
 * @param {number} status&#13;
 * @param {Object&lt;string, string&gt;} headers&#13;
 */&#13;
function makeRes(body, status = 200, headers = {}) {&#13;
    headers['access-control-allow-origin'] = '*'&#13;
    return new Response(body, {status, headers})&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @param {string} urlStr&#13;
 */&#13;
function newUrl(urlStr) {&#13;
    try {&#13;
        return new URL(urlStr)&#13;
    } catch (err) {&#13;
        return null&#13;
    }&#13;
}&#13;
&#13;
&#13;
addEventListener('fetch', e =&gt; {&#13;
    const ret = fetchHandler(e)&#13;
        .catch(err =&gt; makeRes('cfworker error:\n' + err.stack, 502))&#13;
    e.respondWith(ret)&#13;
})&#13;
&#13;
&#13;
/**&#13;
 * @param {FetchEvent} e&#13;
 */&#13;
async function fetchHandler(e) {&#13;
    const getReqHeader = (key) =&gt; e.request.headers.get(key);&#13;
&#13;
    let url = new URL(e.request.url);&#13;
&#13;
    // 修改 pre head get 请求&#13;
    // 是否含有 %2F ，用于判断是否具有用户名与仓库名之间的连接符&#13;
    // 同时检查 %3A 的存在&#13;
    if (!/%2F/.test(url.search) &amp;&amp; /%3A/.test(url.toString())) {&#13;
        let modifiedUrl = url.toString().replace(/%3A(?=.*?&amp;)/, '%3Alibrary%2F');&#13;
        url = new URL(modifiedUrl);&#13;
        console.log(`handle_url: ${url}`)&#13;
    }&#13;
&#13;
    if (url.pathname === '/token') {&#13;
        let token_parameter = {&#13;
            headers: {&#13;
                'Host': 'auth.docker.io',&#13;
                'User-Agent': getReqHeader('User-Agent'),&#13;
                'Accept': getReqHeader('Accept'),&#13;
                'Accept-Language': getReqHeader('Accept-Language'),&#13;
                'Accept-Encoding': getReqHeader('Accept-Encoding'),&#13;
                'Connection': 'keep-alive',&#13;
                'Cache-Control': 'max-age=0'&#13;
            }&#13;
        };&#13;
        let token_url = auth_url + url.pathname + url.search&#13;
        return fetch(new Request(token_url, e.request), token_parameter)&#13;
    }&#13;
&#13;
// 修改 head 请求&#13;
    if (/^\/v2\/[^/]+\/[^/]+\/[^/]+$/.test(url.pathname) &amp;&amp; !/^\/v2\/library/.test(url.pathname)) {&#13;
        url.pathname = url.pathname.replace(/\/v2\//, '/v2/library/');&#13;
        console.log(`modified_url: ${url.pathname}`)&#13;
    }&#13;
&#13;
    url.hostname = hub_host;&#13;
&#13;
    let parameter = {&#13;
        headers: {&#13;
            'Host': hub_host,&#13;
            'User-Agent': getReqHeader('User-Agent'),&#13;
            'Accept': getReqHeader('Accept'),&#13;
            'Accept-Language': getReqHeader('Accept-Language'),&#13;
            'Accept-Encoding': getReqHeader('Accept-Encoding'),&#13;
            'Connection': 'keep-alive',&#13;
            'Cache-Control': 'max-age=0'&#13;
        },&#13;
        cacheTtl: 3600&#13;
    };&#13;
&#13;
    if (e.request.headers.has('Authorization')) {&#13;
        parameter.headers.Authorization = getReqHeader('Authorization');&#13;
    }&#13;
&#13;
    let original_response = await fetch(new Request(url, e.request), parameter)&#13;
    let original_response_clone = original_response.clone();&#13;
    let original_text = original_response_clone.body;&#13;
    let response_headers = original_response.headers;&#13;
    let new_response_headers = new Headers(response_headers);&#13;
    let status = original_response.status;&#13;
&#13;
    if (new_response_headers.get('Www-Authenticate')) {&#13;
        let auth = new_response_headers.get('Www-Authenticate');&#13;
        let re = new RegExp(auth_url, 'g');&#13;
        new_response_headers.set('Www-Authenticate', response_headers.get('Www-Authenticate').replace(re, workers_url));&#13;
    }&#13;
&#13;
    if (new_response_headers.get('Location')) {&#13;
        return httpHandler(e.request, new_response_headers.get('Location'))&#13;
    }&#13;
&#13;
    let response = new Response(original_text, {&#13;
        status,&#13;
        headers: new_response_headers&#13;
    })&#13;
    return response;&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @param {Request} req&#13;
 * @param {string} pathname&#13;
 */&#13;
function httpHandler(req, pathname) {&#13;
    const reqHdrRaw = req.headers&#13;
&#13;
    // preflight&#13;
    if (req.method === 'OPTIONS' &amp;&amp;&#13;
        reqHdrRaw.has('access-control-request-headers')&#13;
    ) {&#13;
        return new Response(null, PREFLIGHT_INIT)&#13;
    }&#13;
&#13;
    let rawLen = ''&#13;
&#13;
    const reqHdrNew = new Headers(reqHdrRaw)&#13;
&#13;
    const refer = reqHdrNew.get('referer')&#13;
&#13;
    let urlStr = pathname&#13;
&#13;
    const urlObj = newUrl(urlStr)&#13;
&#13;
    /** @type {RequestInit} */&#13;
    const reqInit = {&#13;
        method: req.method,&#13;
        headers: reqHdrNew,&#13;
        redirect: 'follow',&#13;
        body: req.body&#13;
    }&#13;
    return proxy(urlObj, reqInit, rawLen)&#13;
}&#13;
&#13;
&#13;
/**&#13;
 *&#13;
 * @param {URL} urlObj&#13;
 * @param {RequestInit} reqInit&#13;
 */&#13;
async function proxy(urlObj, reqInit, rawLen) {&#13;
    const res = await fetch(urlObj.href, reqInit)&#13;
    const resHdrOld = res.headers&#13;
    const resHdrNew = new Headers(resHdrOld)&#13;
&#13;
    // verify&#13;
    if (rawLen) {&#13;
        const newLen = resHdrOld.get('content-length') || ''&#13;
        const badLen = (rawLen !== newLen)&#13;
&#13;
        if (badLen) {&#13;
            return makeRes(res.body, 400, {&#13;
                '--error': `bad len: ${newLen}, except: ${rawLen}`,&#13;
                'access-control-expose-headers': '--error',&#13;
            })&#13;
        }&#13;
    }&#13;
    const status = res.status&#13;
    resHdrNew.set('access-control-expose-headers', '*')&#13;
    resHdrNew.set('access-control-allow-origin', '*')&#13;
    resHdrNew.set('Cache-Control', 'max-age=1500')&#13;
&#13;
    resHdrNew.delete('content-security-policy')&#13;
    resHdrNew.delete('content-security-policy-report-only')&#13;
    resHdrNew.delete('clear-site-data')&#13;
&#13;
    return new Response(res.body, {&#13;
        status,&#13;
        headers: resHdrNew&#13;
    })&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://tiga210.github.io/post/shi-yong-Cloudflare-dai-li-Docker%20hub.html</guid><pubDate>Thu, 20 Jun 2024 13:24:18 +0000</pubDate></item><item><title>Caddy跨域访问配置</title><link>https://tiga210.github.io/post/Caddy-kua-yu-fang-wen-pei-zhi.html</link><description>```&#13;
域名 {&#13;
        header {&#13;
                Access-Control-Allow-Origin *&#13;
                Access-Control-Allow-Methods 'GET, POST, OPTIONS'&#13;
                Access-Control-Allow-Headers 'Content-Type, Authorization'&#13;
                Access-Control-Allow-Credentials true&#13;
        }&#13;
&#13;
        # 处理 OPTIONS 预检请求&#13;
        @preflight {&#13;
                method OPTIONS&#13;
        }&#13;
        handle @preflight {&#13;
                respond 'OK' 204&#13;
        }&#13;
&#13;
        # 反向代理设置&#13;
        reverse_proxy /* tg03:8080 {&#13;
                header_up Access-Control-Allow-Origin *&#13;
                header_up Access-Control-Allow-Methods 'GET, POST, OPTIONS'&#13;
                header_up Access-Control-Allow-Headers 'Content-Type, Authorization'&#13;
                header_up Access-Control-Allow-Credentials true&#13;
        }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://tiga210.github.io/post/Caddy-kua-yu-fang-wen-pei-zhi.html</guid><pubDate>Thu, 20 Jun 2024 05:47:02 +0000</pubDate></item></channel></rss>